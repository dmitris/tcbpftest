"/* automatically generated by rust-bindgen 0.60.1 */\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct __BindgenBitfieldUnit<Storage> {\n    storage: Storage,\n}\nimpl<Storage> __BindgenBitfieldUnit<Storage> {\n    #[inline]\n    pub const fn new(storage: Storage) -> Self {\n        Self { storage }\n    }\n}\nimpl<Storage> __BindgenBitfieldUnit<Storage>\nwhere\n    Storage: AsRef<[u8]> + AsMut<[u8]>,\n{\n    #[inline]\n    pub fn get_bit(&self, index: usize) -> bool {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n        let byte_index = index / 8;\n        let byte = self.storage.as_ref()[byte_index];\n        let bit_index = if cfg!(target_endian = \"big\") {\n            7 - (index % 8)\n        } else {\n            index % 8\n        };\n        let mask = 1 << bit_index;\n        byte & mask == mask\n    }\n    #[inline]\n    pub fn set_bit(&mut self, index: usize, val: bool) {\n        debug_assert!(index / 8 < self.storage.as_ref().len());\n        let byte_index = index / 8;\n        let byte = &mut self.storage.as_mut()[byte_index];\n        let bit_index = if cfg!(target_endian = \"big\") {\n            7 - (index % 8)\n        } else {\n            index % 8\n        };\n        let mask = 1 << bit_index;\n        if val {\n            *byte |= mask;\n        } else {\n            *byte &= !mask;\n        }\n    }\n    #[inline]\n    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n        let mut val = 0;\n        for i in 0..(bit_width as usize) {\n            if self.get_bit(i + bit_offset) {\n                let index = if cfg!(target_endian = \"big\") {\n                    bit_width as usize - 1 - i\n                } else {\n                    i\n                };\n                val |= 1 << index;\n            }\n        }\n        val\n    }\n    #[inline]\n    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {\n        debug_assert!(bit_width <= 64);\n        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());\n        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());\n        for i in 0..(bit_width as usize) {\n            let mask = 1 << i;\n            let val_bit_is_set = val & mask == mask;\n            let index = if cfg!(target_endian = \"big\") {\n                bit_width as usize - 1 - i\n            } else {\n                i\n            };\n            self.set_bit(index + bit_offset, val_bit_is_set);\n        }\n    }\n}\npub type __u8 = ::aya_bpf::cty::c_uchar;\npub type __u16 = ::aya_bpf::cty::c_ushort;\npub type __u32 = ::aya_bpf::cty::c_uint;\npub type __be16 = __u16;\npub type __be32 = __u32;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct ethhdr {\n    pub h_dest: [::aya_bpf::cty::c_uchar; 6usize],\n    pub h_source: [::aya_bpf::cty::c_uchar; 6usize],\n    pub h_proto: __be16,\n}\npub type __sum16 = __u16;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct iphdr {\n    pub _bitfield_align_1: [u8; 0],\n    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,\n    pub tos: __u8,\n    pub tot_len: __be16,\n    pub id: __be16,\n    pub frag_off: __be16,\n    pub ttl: __u8,\n    pub protocol: __u8,\n    pub check: __sum16,\n    pub saddr: __be32,\n    pub daddr: __be32,\n}\nimpl iphdr {\n    #[inline]\n    pub fn ihl(&self) -> __u8 {\n        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }\n    }\n    #[inline]\n    pub fn set_ihl(&mut self, val: __u8) {\n        unsafe {\n            let val: u8 = ::core::mem::transmute(val);\n            self._bitfield_1.set(0usize, 4u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn version(&self) -> __u8 {\n        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }\n    }\n    #[inline]\n    pub fn set_version(&mut self, val: __u8) {\n        unsafe {\n            let val: u8 = ::core::mem::transmute(val);\n            self._bitfield_1.set(4usize, 4u8, val as u64)\n        }\n    }\n    #[inline]\n    pub fn new_bitfield_1(ihl: __u8, version: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {\n        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();\n        __bindgen_bitfield_unit.set(0usize, 4u8, {\n            let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };\n            ihl as u64\n        });\n        __bindgen_bitfield_unit.set(4usize, 4u8, {\n            let version: u8 = unsafe { ::core::mem::transmute(version) };\n            version as u64\n        });\n        __bindgen_bitfield_unit\n    }\n}\n"